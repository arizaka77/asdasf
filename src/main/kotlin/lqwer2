import org.jsoup.Jsoup


fun main(args: Array<String>){
    Jsoup.connect("https://yandex.ru/pogoda/moscow").get().run {
        select("span.temp__value").forEachIndexed { index, element ->
            //val titleOfSearchResult = element.select("h3")
            println(element.text())
        }
    }
}
функции
fun main(args: Array<String>) {

    factorial(4)
    factorial(5)
    factorial(6)
}

fun factorial(n: Int){

    var result = 1;
    for(d in 1..n){
        result *= d
    }
    println("Factorial of $n is equal to $result")
}
.....................................................................................................................................
Лямбда-выражения оборачиваются в фигурные скобки:

1
{println("hello")}
В данном случае лямбда-выражение выводит на консоль строку "hello".

Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию.

1
2
3
4
5
6
fun main(args: Array<String>) {

    val hello = {println("hello")}
    hello()
    hello()
}
В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза.

Также лямбда-выражение можно выполнить сразу при определении с помощью оператора run:

1
2
3
4
fun main(args: Array<String>) {

    run {println("hello")}
}
Передача параметров
Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка ->. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки.

1
2
3
4
5
6
fun main(args: Array<String>) {

    val printer = {message: String -> println(message)}
    printer("Hello")
    printer("Good Bye")
}
Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль.

Если параметров несколько, то они передаются слева от стрелки через запятую:

1
2
3
4
5
6
fun main(args: Array<String>) {

    val sum = {x:Int, y:Int -> println(x + y)}
    sum(2, 3)   // 5
    sum(4, 5)   // 9
}
Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:

1
2
3
4
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
}
Возвращение результата
Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной.

Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:

1
2
3
4
5
val hello = { println("Hello")}
val h = hello()             // h представляет тип Unit

val printer = {message: String -> println(message)}
val p = printer("Welcome")    // p представляет тип Unit
В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа Unit).

Но также может возвращаться конкретное значение:

1
2
3
4
5
6
7
8
fun main(args: Array<String>) {

    val sum = {x:Int, y:Int -> x + y}

    val a = sum(2, 3)   // 5
    val b = sum(4, 5)   // 9
    println("a=$a  b=$b")
}
Здесь выражение справа от стрелки x + y продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной.

Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:

1
2
3
4
5
val sum = {x:Int, y:Int ->
    val result = x + y
    println("$x + $y = $result")
    result
}
Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения.

------------------------------------------------------------------------------------------------------------------------------------

class Person{
    var name: String = "Tom"
    var age: Int = 18
}
В данном случае в классе Person, который представляет человека, определены свойства name (имя человека) и age (возраст человека). И эти свойства инициализированы начальными значениями.

Поскольку эти свойства определены с var, то мы можем изменить их начальные значения:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
fun main(args: Array<String>) {

    val bob: Person = Person()  // создаем объект
    println(bob.name)       // Tom
    println(bob.age)        // 18

    bob.name = "Bob"
    bob.age = 25

    println(bob.name)       // Bob
    println(bob.age)        // 25
}

class Person{
    var name: String = "Tom"
    var age: Int = 18
}
Для обращения к свойствам используется имя переменной, которая предствляет объект, и после точки указывается имя свойства. Например, получение значения свойства:

1
val personName : String = bob.name
Установка значения свойства:

1
bob.name = "Bob"
Геттеры и сеттеры
Для каждого свойства можно определять геттер и сеттер.

Геттер
Геттер управляет получением значения свойства и определяется с помощью слова get:

1
2
3
4
5
6
7
class Person{
    var name: String = "Tom"
    var age: Int = 18

    val info: String
        get() = "Name: $name  Age: $age"
}
Здесь свойство info определяет блок get, который возвращает информацию с именем и возрастом человека. То есть при получении значения свойства мы будем получать именно те данные, которые возвращаются блоком get.

Стоит отметить, что свойство, которое определено с помощью val и у которого явным образом определен блок get, можно не инициализировать. Также стоит отметить, что это свойство неизменяемое, мы не можем извне явным образом изменить его значение, так как оно определено с помощью val. Однако мы можем изменить имя и возраст, и тогда свойство info будет возвращать измененную информацию:

1
2
3
4
5
6
7
8
9
fun main(args: Array<String>) {

    val bob: Person = Person()
    bob.name = "Bob"
    bob.age = 25

    println(bob.info)   // Name: Bob    Age: 25
    // bob.info = "qwerty" // так нельзя - свойство info неизменяемое
}
Сеттер
Сеттер определяет логику установки значения. Он определяется с помощью слова set. Например, выше определено свойство age, которое хранит возраст пользователя, но теоретически мы можем установить любой возраст: 2, 6, -200, 100500. И не все эти значения будут корректными. Например, у человека не может быть отрицательного возраста. И для проверки входных значений можно использовать сеттер:

1
2
3
4
5
6
7
8
9
10
11
12
class Person{
    var name: String = "Tom"

    var age: Int = 18
    set(value){
        if((value>0) and (value <110))
            field = value
    }

    val info: String
        get() = "Name: $name  Age: $age"
}
Блок set определяется также, как и блок get, сразу после свойства, при этом блок set фактически представляет собой функцию, которая принимает один параметр - value, через этот параметр передается устанавливаемое значение. Например, в выражении bob.age = 25 число 25 и будет представлять тот объект, который будет храниться в value.

В блоке set проверяем, входит ли устанавливаемое значение в диапазон допустимых значений. Если входит, то есть если значение корректно, то передаем его объекту field. Если значение некорректно, то свойство просто сохраняет свое предыдущее значение.

Идентификатор field представляет автоматически генерируемое поле, которое непосредственно хранит значение свойства. То есть свойства фактически представляют надстройку над полями, но напрямую в классе мы не можем определять поля, мы можем работать только со свойствами. Стоит отметить, что к полю через идентификатор field можно обратиться только в геттере или в сеттер, и в каждом конкретном свойстве можно обращаться только к своему полю.

Используем сеттер:

1
2
3
4
5
6
7
8
9
10
fun main(args: Array<String>) {

    val bob: Person = Person()
    bob.name = "Bob"
    bob.age = 25        // вызываем сеттер

    println(bob.info)   // Name: Bob    Age: 25
    bob.age = -8        // вызываем сеттер
    println(bob.info)   // Name: Bob    Age: 25
}
При втором обращении к сеттеру (bob.age = -8) можно заметить, что значение свойства age не изменилось. Так как новое значение -8 не входит в диапазон от 0 до 110.

Можно использовать одновременно и геттер, и сеттер:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
class Person{
    var name: String = "Tom"
    get(){
        return  field.toUpperCase()
    }
    set(value){
        if(value.length > 2)
            field = value
    }

    var age: Int = 18
    set(value){
        if((value > 0) and (value < 110))
            field = value
    }

    val info: String
        get() = "Name: $name  Age: $age"
}


